package org.akazukin.intellij.background.gui;import com.intellij.ide.util.PropertiesComponent;import com.intellij.openapi.components.State;import com.intellij.openapi.components.Storage;import com.intellij.openapi.options.Configurable;import com.intellij.openapi.options.ConfigurationException;import com.intellij.openapi.ui.ComboBox;import com.intellij.openapi.util.Pair;import java.io.File;import java.util.ArrayList;import java.util.Arrays;import java.util.HashSet;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import java.util.concurrent.TimeUnit;import java.util.stream.Collectors;import java.util.stream.IntStream;import javax.swing.JCheckBox;import javax.swing.JComponent;import javax.swing.JPanel;import javax.swing.JSpinner;import javax.swing.SpinnerNumberModel;import org.akazukin.intellij.background.EditorBackgroundImage;import org.akazukin.intellij.background.Utils;import org.akazukin.intellij.background.tasks.BackgroundScheduler;import org.jetbrains.annotations.Nullable;@State(    name = EditorBackgroundImage.PLUGIN_NAME + "ConfigConfig",    storages = {@Storage(EditorBackgroundImage.PLUGIN_NAME + "Config.xml")})public final class Settings implements Configurable {    public static final String IMAGE = EditorBackgroundImage.PLUGIN_ID + ".images";    public static final String IMAGES_ID = EditorBackgroundImage.PLUGIN_ID + ".images";    public static final String CHANGE_EVERY = EditorBackgroundImage.PLUGIN_ID + ".change";    public static final String SYNCHRONIZE_IMAGE = EditorBackgroundImage.PLUGIN_ID + ".synchronize";    public static final String INTERVAL = EditorBackgroundImage.PLUGIN_ID + ".interval.amount";    public static final String TIME_UNIT = EditorBackgroundImage.PLUGIN_ID + ".interval.unit";    public static final String EDITOR_BUTTON = EditorBackgroundImage.PLUGIN_ID + ".change.editor";    public static final String FRAME_BUTTON = EditorBackgroundImage.PLUGIN_ID + ".change.frame";    public static final Integer INTERVAL_SPINNER_DEFAULT = 0;    public static final Integer TIME_UNIT_DEFAULT = 1;    public static final TimeUnit[] TIME_UNITS = new TimeUnit[]{        TimeUnit.SECONDS, TimeUnit.MINUTES, TimeUnit.HOURS    };    private JPanel rootPanel;    private JCheckBox changeEveryButton;    private JSpinner intervalSpinner;    private ComboBox<String> timeUnitBox;    private JCheckBox synchronizeImageButton;    private JCheckBox editorButton;    private JCheckBox frameButton;    private Panel backgroundsListPanel;    @Override    public String getDisplayName() {        return EditorBackgroundImage.PLUGIN_NAME_SPACE;    }    @Nullable    @Override    public String getHelpTopic() {        return null;    }    @Nullable    @Override    public JComponent createComponent() {        BackgroundScheduler.shutdown();        intervalSpinner.setModel(new SpinnerNumberModel(0, 0, 360, 2));        changeEveryButton.addActionListener(e -> {            intervalSpinner.setEnabled(changeEveryButton.isSelected());            timeUnitBox.setEnabled(changeEveryButton.isSelected());        });        for (TimeUnit timeUnit : TIME_UNITS) {            timeUnitBox.addItem(timeUnit.name());        }        return rootPanel;    }    @Override    public boolean isModified() {        PropertiesComponent props = PropertiesComponent.getInstance();        List<Pair<File, Boolean>> backgrounds = getBackgroundInProperties();        return !new HashSet<>(backgrounds).containsAll(backgroundsListPanel.getDataAsMap().entrySet())            || !new HashSet<>(backgroundsListPanel.getDataAsMap().entrySet()).containsAll(backgrounds)            || props.getInt(INTERVAL, INTERVAL_SPINNER_DEFAULT) != ((SpinnerNumberModel) intervalSpinner.getModel()).getNumber().intValue()            || timeUnitBox.getSelectedIndex() != props.getInt(TIME_UNIT, TIME_UNIT_DEFAULT)            || props.getBoolean(EDITOR_BUTTON) != editorButton.isSelected()            || props.getBoolean(FRAME_BUTTON) != frameButton.isSelected()            || props.getBoolean(CHANGE_EVERY) != changeEveryButton.isSelected()            || props.getBoolean(SYNCHRONIZE_IMAGE) != synchronizeImageButton.isSelected();    }    @Override    public void apply() throws ConfigurationException {        PropertiesComponent props = PropertiesComponent.getInstance();        boolean changeEvery = changeEveryButton.isSelected();        int interval = ((SpinnerNumberModel) intervalSpinner.getModel()).getNumber().intValue();        if (props.isValueSet(IMAGES_ID) && !props.getValue(IMAGES_ID).isEmpty()) {            int[] ids = Arrays.stream(props.getValue(IMAGES_ID).split(",")).map(Integer::valueOf).mapToInt(i -> i).toArray();            for (int id : ids) {                props.unsetValue(IMAGE + "." + id + ".Path");                props.unsetValue(IMAGE + "." + id + ".Enabled");            }        }        props.setValue(IMAGES_ID, IntStream.range(0, backgroundsListPanel.getData().size()).mapToObj(String::valueOf).collect(Collectors.joining(",")));        for (int id = 0; id < backgroundsListPanel.getData().size(); id++) {            Pair<File, Boolean> data = backgroundsListPanel.getData().get(id);            props.setValue(IMAGE + "." + id + ".Path", data.first.getPath());            props.setValue(IMAGE + "." + id + ".Enabled", data.second.toString());        }        props.setValue(INTERVAL, interval, INTERVAL_SPINNER_DEFAULT);        props.setValue(CHANGE_EVERY, changeEvery);        props.setValue(SYNCHRONIZE_IMAGE, synchronizeImageButton.isSelected());        props.setValue(TIME_UNIT, timeUnitBox.getSelectedIndex(), TIME_UNIT_DEFAULT);        props.setValue(EDITOR_BUTTON, editorButton.isSelected());        props.setValue(FRAME_BUTTON, frameButton.isSelected());        intervalSpinner.setEnabled(changeEvery);    }    @Override    public void reset() {        PropertiesComponent props = PropertiesComponent.getInstance();        changeEveryButton.setSelected(props.getBoolean(CHANGE_EVERY, false));        intervalSpinner.setValue(props.getInt(INTERVAL, INTERVAL_SPINNER_DEFAULT));        intervalSpinner.setEnabled(changeEveryButton.isSelected());        timeUnitBox.setSelectedIndex(props.getInt(TIME_UNIT, TIME_UNIT_DEFAULT));        timeUnitBox.setEnabled(changeEveryButton.isSelected());        editorButton.setSelected(props.getBoolean(EDITOR_BUTTON, false));        frameButton.setSelected(props.getBoolean(FRAME_BUTTON, false));        synchronizeImageButton.setSelected(props.getBoolean(SYNCHRONIZE_IMAGE, false));        backgroundsListPanel.setData(getBackgroundInProperties());    }    @Override    public void disposeUIResources() {        boolean autoChange = changeEveryButton.isSelected();        int interval = ((SpinnerNumberModel) intervalSpinner.getModel()).getNumber().intValue();        EditorBackgroundImage.setImageCache(null);        if (autoChange && interval > 0) {            BackgroundScheduler.schedule();        } else {            BackgroundScheduler.shutdown();        }    }    public List<Pair<File, Boolean>> getBackgroundInProperties() {        PropertiesComponent props = PropertiesComponent.getInstance();        Map<File, Boolean> backgrounds = new LinkedHashMap<>();        if (props.isValueSet(IMAGES_ID) && !props.getValue(IMAGES_ID).isEmpty()) {            return new ArrayList<>(                Arrays.stream(props.getValue(IMAGES_ID).split(","))                    .filter(id -> props.isValueSet(IMAGE + "." + id + ".Path"))                    .map(id -> Pair.pair(                        new File(props.getValue(IMAGE + "." + id + ".Path")),                        Utils.getBoolean(props.getValue(IMAGE + "." + id + ".Enabled", "true"))                    ))                    .toList());        }        return new ArrayList<>();    }}